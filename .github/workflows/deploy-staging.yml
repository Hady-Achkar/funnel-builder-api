name: Deploy to Staging Azure VM

on:
  push:
    branches: [ develop ]
  workflow_dispatch:

env:
  NODE_VERSION: '20.x'
  PNPM_VERSION: 'latest'

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: funnel_builder_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}

    - name: Setup pnpm
      uses: pnpm/action-setup@v2
      with:
        version: ${{ env.PNPM_VERSION }}

    - name: Get pnpm store directory
      shell: bash
      run: |
        echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

    - name: Setup pnpm cache
      uses: actions/cache@v3
      with:
        path: ${{ env.STORE_PATH }}
        key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          ${{ runner.os }}-pnpm-store-

    - name: Install dependencies
      run: pnpm install --frozen-lockfile

    - name: Generate Prisma client
      run: pnpm exec prisma generate
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/funnel_builder_test

    - name: Run database migrations
      run: pnpm exec prisma migrate deploy
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/funnel_builder_test

    - name: Run tests
      run: pnpm test run
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/funnel_builder_test
        REDIS_URL: redis://localhost:6379
        JWT_SECRET: test-secret-key
        NODE_ENV: test

    - name: Build application
      run: pnpm run build

  deploy:
    needs: test
    runs-on: ubuntu-latest
    environment: dev
    
    steps:
    - name: Check deployment secrets
      run: |
        echo "Checking secrets availability..."
        echo "AZURE_STAGING_HOST length: ${#AZURE_STAGING_HOST}"
        echo "AZURE_STAGING_USERNAME length: ${#AZURE_STAGING_USERNAME}"
        echo "AZURE_STAGING_SSH_KEY length: ${#AZURE_STAGING_SSH_KEY}"
        
        if [ -z "$AZURE_STAGING_HOST" ]; then
          echo "ERROR: AZURE_STAGING_HOST secret is not set or empty"
          exit 1
        fi
        if [ -z "$AZURE_STAGING_USERNAME" ]; then
          echo "ERROR: AZURE_STAGING_USERNAME secret is not set or empty"
          exit 1
        fi
        if [ -z "$AZURE_STAGING_SSH_KEY" ]; then
          echo "ERROR: AZURE_STAGING_SSH_KEY secret is not set or empty"
          exit 1
        fi
        echo "âœ… All required secrets are configured"
      env:
        AZURE_STAGING_HOST: ${{ secrets.AZURE_STAGING_HOST }}
        AZURE_STAGING_USERNAME: ${{ secrets.AZURE_STAGING_USERNAME }}
        AZURE_STAGING_SSH_KEY: ${{ secrets.AZURE_STAGING_SSH_KEY }}

    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}

    - name: Setup pnpm
      uses: pnpm/action-setup@v2
      with:
        version: ${{ env.PNPM_VERSION }}

    - name: Install all dependencies for build
      run: pnpm install --frozen-lockfile

    - name: Generate Prisma client
      run: pnpm exec prisma generate

    - name: Build application
      run: pnpm run build

    - name: Prune dev dependencies
      run: pnpm prune --prod

    - name: Create deployment package
      run: |
        mkdir -p deploy
        cp -r dist/ deploy/
        cp -r src/generated/ deploy/
        cp -r node_modules/ deploy/
        cp package.json deploy/
        cp pnpm-lock.yaml deploy/
        cp -r prisma/ deploy/
        cp docker-compose.staging.yml deploy/
        cp .env.staging deploy/
        
        # Create deployment scripts
        cat > deploy/deploy.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "Starting staging deployment..."
        
        # Install Docker if not present
        if ! command -v docker &> /dev/null; then
          echo "Docker not found, installing..."
          
          # Update package index
          sudo apt-get update
          
          # Install required packages
          sudo apt-get install -y \
            ca-certificates \
            curl \
            gnupg \
            lsb-release
          
          # Add Docker's official GPG key
          sudo mkdir -p /etc/apt/keyrings
          curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
          
          # Set up repository
          echo \
            "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
            $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
          
          # Install Docker Engine
          sudo apt-get update
          sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
          
          # Add user to docker group
          sudo usermod -aG docker $USER
          
          # Start Docker service
          sudo systemctl start docker
          sudo systemctl enable docker
          
          echo "Docker installation completed"
        fi
        
        # Install Docker Compose if not present
        if ! command -v docker-compose &> /dev/null; then
          echo "Installing Docker Compose..."
          sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          echo "Docker Compose installation completed"
        fi
        
        # Stop and remove existing containers
        sudo docker-compose -f docker-compose.staging.yml down || echo "No existing containers to stop"
        
        # Start Docker services
        sudo docker-compose -f docker-compose.staging.yml up -d
        
        # Wait for services to be ready
        echo "Waiting for database to be ready..."
        sleep 10
        
        # Stop existing application
        pm2 stop funnel-builder-staging || echo "No existing process to stop"
        
        # Backup current deployment
        if [ -d "/opt/funnel-builder-staging" ]; then
          sudo cp -r /opt/funnel-builder-staging /opt/funnel-builder-staging.backup.$(date +%Y%m%d_%H%M%S)
        fi
        
        # Create application directory
        sudo mkdir -p /opt/funnel-builder-staging
        
        # Copy new files
        sudo cp -r ./* /opt/funnel-builder-staging/
        
        # Set permissions
        sudo chown -R $USER:$USER /opt/funnel-builder-staging
        cd /opt/funnel-builder-staging
        
        # Load environment variables
        source .env.staging
        
        # Run database migrations
        npx prisma migrate deploy
        
        # Start application with PM2
        pm2 start ecosystem.config.js || pm2 start dist/server.js --name funnel-builder-staging
        pm2 save
        
        echo "Staging deployment completed successfully!"
        EOF
        
        chmod +x deploy/deploy.sh

    - name: Create ecosystem.config.js for staging
      run: |
        cat > deploy/ecosystem.config.js << 'EOF'
        module.exports = {
          apps: [{
            name: 'funnel-builder-staging',
            script: 'dist/server.js',
            instances: 1,
            exec_mode: 'cluster',
            env: {
              NODE_ENV: 'staging',
              PORT: 3001
            },
            error_file: '/var/log/funnel-builder-staging/error.log',
            out_file: '/var/log/funnel-builder-staging/out.log',
            log_file: '/var/log/funnel-builder-staging/combined.log',
            time: true,
            wait_ready: true,
            listen_timeout: 10000
          }]
        };
        EOF

    - name: Copy files to Azure Staging VM
      uses: appleboy/scp-action@v0.1.4
      with:
        host: ${{ secrets.AZURE_STAGING_HOST }}
        username: ${{ secrets.AZURE_STAGING_USERNAME }}
        key: ${{ secrets.AZURE_STAGING_SSH_KEY }}
        port: ${{ secrets.AZURE_STAGING_PORT || 22 }}
        source: "deploy/*"
        target: "~/staging-deployment/"
        strip_components: 1
        overwrite: true

    - name: Execute staging deployment
      uses: appleboy/ssh-action@v1.0.0
      env:
        CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        CLOUDFLARE_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
        CLOUDFLARE_SAAS_TARGET: ${{ secrets.CLOUDFLARE_SAAS_TARGET }}
        PLATFORM_MAIN_DOMAIN: ${{ secrets.PLATFORM_MAIN_DOMAIN }}
      with:
        host: ${{ secrets.AZURE_STAGING_HOST }}
        username: ${{ secrets.AZURE_STAGING_USERNAME }}
        key: ${{ secrets.AZURE_STAGING_SSH_KEY }}
        port: ${{ secrets.AZURE_STAGING_PORT || 22 }}
        envs: CLOUDFLARE_API_TOKEN,CLOUDFLARE_ACCOUNT_ID,CLOUDFLARE_ZONE_ID,CLOUDFLARE_SAAS_TARGET,PLATFORM_MAIN_DOMAIN
        script: |
          # Use the staging deployment directory
          cd ~/staging-deployment
          echo "Current directory: $(pwd)"
          echo "Files in directory: $(ls -la)"
          
          # Install Docker if not available
          if ! command -v docker &> /dev/null; then
            echo "Installing Docker..."
            curl -fsSL https://get.docker.com -o get-docker.sh
            sudo sh get-docker.sh
            sudo usermod -aG docker $USER
            sudo systemctl start docker
            sudo systemctl enable docker
          fi
          
          if ! command -v docker-compose &> /dev/null; then
            echo "Installing Docker Compose..."
            sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
          fi
          
          # Start Docker services for manual deployment
          if [ -f docker-compose.staging.yml ]; then
            echo "Stopping existing Docker services..."
            sudo docker-compose -f docker-compose.staging.yml down || echo "No existing containers to stop"
            echo "Starting Docker services..."
            sudo docker-compose -f docker-compose.staging.yml up -d
            sleep 10
          fi
          
          # Run deployment script
          if [ -f deploy.sh ]; then
            chmod +x deploy.sh
            ./deploy.sh
          else
            echo "Deploy script not found, running manual deployment..."
            
            # Stop existing PM2 process
            pm2 stop funnel-builder-staging || echo "No existing process to stop"
            
            # Install dependencies if needed
            if [ -f package.json ]; then
              npm install --production || echo "Dependencies already installed"
            fi
            
            # Load environment variables and run migrations
            source .env.staging
            npx prisma migrate deploy || echo "No migrations to run"
            
            # Start application with PM2
            pm2 start ecosystem.config.js --env staging || pm2 restart funnel-builder-staging
            pm2 save
            
            echo "Staging deployment completed!"
          fi

    - name: Health check staging
      run: |
        sleep 30
        curl -f http://${{ secrets.AZURE_STAGING_HOST }}:3001/health || exit 1
        echo "Staging deployment health check passed!"

    - name: Run smoke tests on staging
      run: |
        # Basic API tests
        STAGING_URL="http://${{ secrets.AZURE_STAGING_HOST }}:3001"
        
        # Test root endpoint
        curl -f "$STAGING_URL/" || exit 1
        
        # Test health endpoint
        curl -f "$STAGING_URL/health" || exit 1
        
        echo "âœ… Staging smoke tests passed!"

    - name: Notify staging deployment success
      run: |
        echo "âœ… Staging deployment completed successfully!"
        echo "ðŸš€ Staging application is running at: http://${{ secrets.AZURE_STAGING_HOST }}:3001"
        echo "ðŸ“‹ Ready for testing on develop branch"